// src/middleware.ts
import { NextResponse } from "next/server";

// src/lib/auth.ts
function basicAuthentication(authorization) {
  if (!authorization) {
    return void 0;
  }
  const [scheme, encoded] = authorization.split(" ");
  if (!encoded || scheme !== "Basic") {
    throw new BadRequestException("Malformed authorization header.");
  }
  const buffer = Uint8Array.from(
    atob(encoded),
    (character) => character.charCodeAt(0)
  );
  const decoded = new TextDecoder().decode(buffer).normalize();
  const index = decoded.indexOf(":");
  if (index === -1 || /[\0-\x1F\x7F]/.test(decoded)) {
    throw new BadRequestException("Invalid authorization value.");
  }
  return {
    user: decoded.substring(0, index),
    pass: decoded.substring(index + 1)
  };
}
var BadRequestException = class extends Error {
  status;
  statusText;
  reason;
  constructor(reason) {
    super(reason);
    this.status = 400;
    this.statusText = "Bad Request";
    this.reason = reason;
  }
};

// src/lib/compare.ts
var safeCompare = (a, b) => {
  const stringA = String(a);
  const lengthA = stringA.length;
  let stringB = String(b);
  let result = 0;
  if (lengthA !== stringB.length) {
    stringB = stringA;
    result = 1;
  }
  for (let i = 0; i < lengthA; i++) {
    result |= stringA.charCodeAt(i) ^ stringB.charCodeAt(i);
  }
  return result === 0;
};

// src/lib/credentials.ts
var parseCredentials = (credentials) => {
  const authCredentials = [];
  credentials.split("|").forEach((item) => {
    if (item.length < 3) {
      throw new Error(
        `Received incorrect basic auth syntax, use <username>:<password>, received ${item}`
      );
    }
    const parsedCredentials = item.split(":");
    if (parsedCredentials[0].length === 0 || parsedCredentials[1].length === 0) {
      throw new Error(
        `Received incorrect basic auth syntax, use <username>:<password>, received ${item}`
      );
    }
    authCredentials.push({
      name: parsedCredentials[0],
      password: parsedCredentials[1]
    });
  });
  return authCredentials;
};
var compareCredentials = (input, requiredCredentials) => requiredCredentials.some(
  (item) => safeCompare(input.user, item.name) && safeCompare(input.pass, item.password)
);

// src/middleware.ts
var createNextAuthMiddleware = ({ pathname = "/api/auth", users = [] } = {}) => (req) => nextBasicAuthMiddleware({ pathname, users }, req);
var nextBasicAuthMiddleware = ({ pathname = "/api/auth", users = [] } = {}, req) => {
  const environmentCredentials = process.env.BASIC_AUTH_CREDENTIALS || "";
  if (environmentCredentials.length === 0 && users.length === 0) {
    return NextResponse.next();
  }
  const credentialsObject = environmentCredentials.length > 0 ? parseCredentials(environmentCredentials) : users;
  const authHeader = req.headers.get("authorization");
  if (authHeader) {
    const currentUser = basicAuthentication(authHeader);
    if (currentUser && compareCredentials(currentUser, credentialsObject)) {
      return NextResponse.next();
    }
  }
  const url = req.nextUrl;
  url.pathname = pathname;
  return NextResponse.rewrite(url);
};
var createApiPage = (realm = "protected", message = "Authentication failed") => (_, res) => {
  res.setHeader("WWW-Authenticate", `Basic realm="${realm}"`);
  res.statusCode = 401;
  res.end(message);
};
export {
  createApiPage,
  createNextAuthMiddleware,
  nextBasicAuthMiddleware
};
//# sourceMappingURL=index.mjs.map